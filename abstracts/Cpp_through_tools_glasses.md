#A look at C++ through the glasses of a language tool 

With its history going back to the early days of programming, rich heritage, tons of legacy code mixed with modern language features and patterns, quickly evolving language standards, and a variety of tools in the environment, C++ can be tricky and easily enable hacks and inaccurate solutions if you don’t cook it right.

Developing language tools (and IDEs in particular) is a good litmus test for such problems. When a tool gets confused by some code or fails to provide the full intelligence it’s supposed to possess, doesn’t that mean that developers should also pay more attention and be more careful in the same situations? This talk is dedicated to bringing such situations to light and sharing lessons learned.

We’ll cover core language trickiness and peculiarities, including preprocessor and context-dependent parsing, and how the modern language standards can be helpful.

We’ll also look at some good practices that can help prevent shooting yourself in the leg with C++, and will reflect on C++ Code Guidelines.

We’ll analyze the tooling heritage as well, looking at the variety of build systems, compilers, debuggers, unit testing frameworks and package managers. Understanding the drawbacks of how they are integrated into language tools will give us insight into their limitations as well as into more accurate and error-free development in C++.
